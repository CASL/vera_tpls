<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML3.2 EN">
<HTML>
<HEAD> <link rel="canonical" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreateMPIAIJWithSplitArrays.html" />
<META NAME="GENERATOR" CONTENT="DOCTEXT">
<TITLE>MatCreateMPIAIJWithSplitArrays</TITLE>
</HEAD>
<BODY BGCOLOR="FFFFFF">
   <div id="version" align=right><b>petsc-3.5.4 2015-05-23</b></div>
   <div id="bugreport" align=right><a href="mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.5.4 v3.5.3-68-g9fbf19a docs/manualpages/Mat/MatCreateMPIAIJWithSplitArrays.html "><small>Report Typos and Errors</small></a></div>
<A NAME="MatCreateMPIAIJWithSplitArrays"><H1>MatCreateMPIAIJWithSplitArrays</H1></A>
creates a MPI AIJ matrix using arrays that contain the "diagonal" and "off-diagonal" part of the matrix in CSR format. 
<H3><FONT COLOR="#CC3333">Synopsis</FONT></H3>
<PRE>
#include "petscmat.h" 
PetscErrorCode  MatCreateMPIAIJWithSplitArrays(MPI_Comm comm,PetscInt m,PetscInt n,PetscInt M,PetscInt N,PetscInt i[],PetscInt j[],PetscScalar a[],PetscInt oi[], PetscInt oj[],PetscScalar oa[],Mat *mat)
</PRE>
Collective on <A HREF="../Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A>
<P>
<H3><FONT COLOR="#CC3333">Input Parameters</FONT></H3>
<TABLE border="0" cellpadding="0" cellspacing="0">
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>comm </B></TD><TD>- MPI communicator
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>m </B></TD><TD>- number of local rows (Cannot be <A HREF="../Sys/PETSC_DECIDE.html#PETSC_DECIDE">PETSC_DECIDE</A>)
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>n </B></TD><TD>- This value should be the same as the local size used in creating the
x vector for the matrix-vector product y = Ax. (or <A HREF="../Sys/PETSC_DECIDE.html#PETSC_DECIDE">PETSC_DECIDE</A> to have
calculated if N is given) For square matrices n is almost always m.
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>M </B></TD><TD>- number of global rows (or <A HREF="../Sys/PETSC_DETERMINE.html#PETSC_DETERMINE">PETSC_DETERMINE</A> to have calculated if m is given)
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>N </B></TD><TD>- number of global columns (or <A HREF="../Sys/PETSC_DETERMINE.html#PETSC_DETERMINE">PETSC_DETERMINE</A> to have calculated if n is given)
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>i </B></TD><TD>- row indices for "diagonal" portion of matrix
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>j </B></TD><TD>- column indices
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>a </B></TD><TD>- matrix values
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>oi </B></TD><TD>- row indices for "off-diagonal" portion of matrix
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>oj </B></TD><TD>- column indices
</TD></TR>
<TR><TD WIDTH=40></TD><TD ALIGN=LEFT VALIGN=TOP><B>oa </B></TD><TD>- matrix values
</TD></TR></TABLE>
<P>
<H3><FONT COLOR="#CC3333">Output Parameter</FONT></H3>
<DT><B>mat </B> -the matrix
<br>
<P>

<P>
<H3><FONT COLOR="#CC3333">Notes</FONT></H3>
The i, j, and a arrays ARE NOT copied by this routine into the internal format used by PETSc. The user
must free the arrays once the matrix has been destroyed and not before.
<P>
The i and j indices are 0 based
<P>
See <A HREF="../Mat/MatCreateAIJ.html#MatCreateAIJ">MatCreateAIJ</A>() for the definition of "diagonal" and "off-diagonal" portion of the matrix
<P>
This sets local rows and cannot be used to set off-processor values.
<P>
Use of this routine is discouraged because it is inflexible and cumbersome to use. It is extremely rare that a
legacy application natively assembles into exactly this split format. The code to do so is nontrivial and does
not easily support in-place reassembly. It is recommended to use <A HREF="../Mat/MatSetValues.html#MatSetValues">MatSetValues</A>() (or a variant thereof) because
the resulting assembly is easier to implement, will work with any matrix format, and the user does not have to
keep track of the underlying array. Use <A HREF="../Mat/MatSetOption.html#MatSetOption">MatSetOption</A>(A,MAT_IGNORE_OFF_PROC_ENTRIES,<A HREF="../Sys/PETSC_TRUE.html#PETSC_TRUE">PETSC_TRUE</A>) to disable all
communication if it is known that only local entries will be set.
<P>
<H3><FONT COLOR="#CC3333">Keywords</FONT></H3>
 matrix, aij, compressed row, sparse, parallel
<BR>
<P>
<H3><FONT COLOR="#CC3333">See Also</FONT></H3>
 <A HREF="../Mat/MatCreate.html#MatCreate">MatCreate</A>(), <A HREF="../Mat/MatCreateSeqAIJ.html#MatCreateSeqAIJ">MatCreateSeqAIJ</A>(), <A HREF="../Mat/MatSetValues.html#MatSetValues">MatSetValues</A>(), <A HREF="../Mat/MatMPIAIJSetPreallocation.html#MatMPIAIJSetPreallocation">MatMPIAIJSetPreallocation</A>(), <A HREF="../Mat/MatMPIAIJSetPreallocationCSR.html#MatMPIAIJSetPreallocationCSR">MatMPIAIJSetPreallocationCSR</A>(),
<BR>MPIAIJ, <A HREF="../Mat/MatCreateAIJ.html#MatCreateAIJ">MatCreateAIJ</A>(), <A HREF="../Mat/MatCreateMPIAIJWithArrays.html#MatCreateMPIAIJWithArrays">MatCreateMPIAIJWithArrays</A>()
C@*/
<A HREF="../Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A>  <A HREF="../Mat/MatCreateMPIAIJWithSplitArrays.html#MatCreateMPIAIJWithSplitArrays">MatCreateMPIAIJWithSplitArrays</A>(<A HREF="../Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A> comm,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> m,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> n,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> M,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> N,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> i[],<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> j[],<A HREF="../Sys/PetscScalar.html#PetscScalar">PetscScalar</A> a[],<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> oi[], <A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> oj[],<A HREF="../Sys/PetscScalar.html#PetscScalar">PetscScalar</A> oa[],<A HREF="../Mat/Mat.html#Mat">Mat</A> *mat)
{
<A HREF="../Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> ierr;
Mat_MPIAIJ     *maij;
<P>
<A HREF="../Sys/PetscFunctionBegin.html#PetscFunctionBegin">PetscFunctionBegin</A>;
if (m &lt; 0) <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_OUTOFRANGE,"local number of rows (m) cannot be <A HREF="../Sys/PETSC_DECIDE.html#PETSC_DECIDE">PETSC_DECIDE</A>, or negative");
if (i[0]) <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_OUTOFRANGE,"i (row indices) must start with 0");
if (oi[0]) <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_OUTOFRANGE,"oi (row indices) must start with 0");
ierr = <A HREF="../Mat/MatCreate.html#MatCreate">MatCreate</A>(comm,mat);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatSetSizes.html#MatSetSizes">MatSetSizes</A>(*mat,m,n,M,N);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatSetType.html#MatSetType">MatSetType</A>(*mat,<A HREF="../Mat/MATMPIAIJ.html#MATMPIAIJ">MATMPIAIJ</A>);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
maij = (Mat_MPIAIJ*) (*mat)-&gt;data;
<P>
(*mat)-&gt;preallocated = <A HREF="../Sys/PETSC_TRUE.html#PETSC_TRUE">PETSC_TRUE</A>;
<P>
ierr = <A HREF="../IS/PetscLayoutSetUp.html#PetscLayoutSetUp">PetscLayoutSetUp</A>((*mat)-&gt;rmap);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../IS/PetscLayoutSetUp.html#PetscLayoutSetUp">PetscLayoutSetUp</A>((*mat)-&gt;cmap);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
<P>
ierr = <A HREF="../Mat/MatCreateSeqAIJWithArrays.html#MatCreateSeqAIJWithArrays">MatCreateSeqAIJWithArrays</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,m,n,i,j,a,&amp;maij-&gt;A);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatCreateSeqAIJWithArrays.html#MatCreateSeqAIJWithArrays">MatCreateSeqAIJWithArrays</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,m,(*mat)-&gt;cmap-&gt;N,oi,oj,oa,&amp;maij-&gt;B);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
<P>
ierr = <A HREF="../Mat/MatAssemblyBegin.html#MatAssemblyBegin">MatAssemblyBegin</A>(maij-&gt;A,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatAssemblyEnd.html#MatAssemblyEnd">MatAssemblyEnd</A>(maij-&gt;A,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatAssemblyBegin.html#MatAssemblyBegin">MatAssemblyBegin</A>(maij-&gt;B,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatAssemblyEnd.html#MatAssemblyEnd">MatAssemblyEnd</A>(maij-&gt;B,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
<P>
ierr = <A HREF="../Mat/MatAssemblyBegin.html#MatAssemblyBegin">MatAssemblyBegin</A>(*mat,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatAssemblyEnd.html#MatAssemblyEnd">MatAssemblyEnd</A>(*mat,MAT_FINAL_ASSEMBLY);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
ierr = <A HREF="../Mat/MatSetOption.html#MatSetOption">MatSetOption</A>(*mat,MAT_NEW_NONZERO_LOCATION_ERR,<A HREF="../Sys/PETSC_TRUE.html#PETSC_TRUE">PETSC_TRUE</A>);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
<A HREF="../Sys/PetscFunctionReturn.html#PetscFunctionReturn">PetscFunctionReturn</A>(0);
}
<P>
/*
Special version for direct calls from Fortran
*/
#include &lt;petsc-private/fortranimpl.h&gt;
<P>
#if defined(PETSC_HAVE_FORTRAN_CAPS)
#define matsetvaluesmpiaij_ MATSETVALUESMPIAIJ
#elif !defined(PETSC_HAVE_FORTRAN_UNDERSCORE)
#define matsetvaluesmpiaij_ matsetvaluesmpiaij
#endif
<P>
/* Change these macros so can be used in void function */
#undef <A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>
#define <A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr) CHKERRABORT(<A HREF="../Sys/PETSC_COMM_WORLD.html#PETSC_COMM_WORLD">PETSC_COMM_WORLD</A>,ierr)
#undef <A HREF="../Sys/SETERRQ2.html#SETERRQ2">SETERRQ2</A>
#define <A HREF="../Sys/SETERRQ2.html#SETERRQ2">SETERRQ2</A>(comm,ierr,b,c,d) CHKERRABORT(comm,ierr)
#undef <A HREF="../Sys/SETERRQ3.html#SETERRQ3">SETERRQ3</A>
#define <A HREF="../Sys/SETERRQ3.html#SETERRQ3">SETERRQ3</A>(comm,ierr,b,c,d,e) CHKERRABORT(comm,ierr)
#undef <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>
#define <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>(c,ierr,b) CHKERRABORT(c,ierr)
<P>
#undef __FUNCT__
#define __FUNCT__ "matsetvaluesmpiaij_"
PETSC_EXTERN void PETSC_STDCALL matsetvaluesmpiaij_(<A HREF="../Mat/Mat.html#Mat">Mat</A> *mmat,<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> *mm,const <A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> im[],<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> *mn,const <A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A> in[],const <A HREF="../Sys/PetscScalar.html#PetscScalar">PetscScalar</A> v[],<A HREF="../Sys/InsertMode.html#InsertMode">InsertMode</A> *maddv,<A HREF="../Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> *_ierr)
{
<A HREF="../Mat/Mat.html#Mat">Mat</A>            mat  = *mmat;
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>       m    = *mm, n = *mn;
<A HREF="../Sys/InsertMode.html#InsertMode">InsertMode</A>     addv = *maddv;
Mat_MPIAIJ     *aij = (Mat_MPIAIJ*)mat-&gt;data;
<A HREF="../Sys/PetscScalar.html#PetscScalar">PetscScalar</A>    value;
<A HREF="../Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> ierr;
<P>
MatCheckPreallocated(mat,1);
if (mat-&gt;insertmode == NOT_SET_VALUES) mat-&gt;insertmode = addv;
<P>
#if defined(PETSC_USE_DEBUG)
else if (mat-&gt;insertmode != addv) <A HREF="../Sys/SETERRQ.html#SETERRQ">SETERRQ</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_WRONGSTATE,"Cannot mix add values and insert values");
#endif
{
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>  i,j,rstart  = mat-&gt;rmap-&gt;rstart,rend = mat-&gt;rmap-&gt;rend;
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>  cstart      = mat-&gt;cmap-&gt;rstart,cend = mat-&gt;cmap-&gt;rend,row,col;
<A HREF="../Sys/PetscBool.html#PetscBool">PetscBool</A> roworiented = aij-&gt;roworiented;
<P>
/* Some Variables required in the macro */
<A HREF="../Mat/Mat.html#Mat">Mat</A>        A                 = aij-&gt;A;
Mat_SeqAIJ *a                = (Mat_SeqAIJ*)A-&gt;data;
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>   *aimax            = a-&gt;imax,*ai = a-&gt;i,*ailen = a-&gt;ilen,*aj = a-&gt;j;
MatScalar  *aa               = a-&gt;a;
<A HREF="../Sys/PetscBool.html#PetscBool">PetscBool</A>  ignorezeroentries = (((a-&gt;ignorezeroentries)&amp;&amp;(addv==<A HREF="../Sys/ADD_VALUES.html#ADD_VALUES">ADD_VALUES</A>)) ? <A HREF="../Sys/PETSC_TRUE.html#PETSC_TRUE">PETSC_TRUE</A> : <A HREF="../Sys/PETSC_FALSE.html#PETSC_FALSE">PETSC_FALSE</A>);
<A HREF="../Mat/Mat.html#Mat">Mat</A>        B                 = aij-&gt;B;
Mat_SeqAIJ *b                = (Mat_SeqAIJ*)B-&gt;data;
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>   *bimax            = b-&gt;imax,*bi = b-&gt;i,*bilen = b-&gt;ilen,*bj = b-&gt;j,bm = aij-&gt;B-&gt;rmap-&gt;n,am = aij-&gt;A-&gt;rmap-&gt;n;
MatScalar  *ba               = b-&gt;a;
<P>
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>  *rp1,*rp2,ii,nrow1,nrow2,_i,rmax1,rmax2,N,low1,high1,low2,high2,t,lastcol1,lastcol2;
<A HREF="../Sys/PetscInt.html#PetscInt">PetscInt</A>  nonew = a-&gt;nonew;
MatScalar *ap1,*ap2;
<P>
<A HREF="../Sys/PetscFunctionBegin.html#PetscFunctionBegin">PetscFunctionBegin</A>;
for (i=0; i&lt;m; i++) {
if (im[i] &lt; 0) continue;
#if defined(PETSC_USE_DEBUG)
if (im[i] &gt;= mat-&gt;rmap-&gt;N) <A HREF="../Sys/SETERRQ2.html#SETERRQ2">SETERRQ2</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_OUTOFRANGE,"Row too large: row %D max %D",im[i],mat-&gt;rmap-&gt;N-1);
#endif
if (im[i] &gt;= rstart &amp;&amp; im[i] &lt; rend) {
row      = im[i] - rstart;
lastcol1 = -1;
rp1      = aj + ai[row];
ap1      = aa + ai[row];
rmax1    = aimax[row];
nrow1    = ailen[row];
low1     = 0;
high1    = nrow1;
lastcol2 = -1;
rp2      = bj + bi[row];
ap2      = ba + bi[row];
rmax2    = bimax[row];
nrow2    = bilen[row];
low2     = 0;
high2    = nrow2;
<P>
for (j=0; j&lt;n; j++) {
if (roworiented) value = v[i*n+j];
else value = v[i+j*m];
if (ignorezeroentries &amp;&amp; value == 0.0 &amp;&amp; (addv == <A HREF="../Sys/ADD_VALUES.html#ADD_VALUES">ADD_VALUES</A>)) continue;
if (in[j] &gt;= cstart &amp;&amp; in[j] &lt; cend) {
col = in[j] - cstart;
MatSetValues_SeqAIJ_A_Private(row,col,value,addv);
} else if (in[j] &lt; 0) continue;
#if defined(PETSC_USE_DEBUG)
else if (in[j] &gt;= mat-&gt;cmap-&gt;N) <A HREF="../Sys/SETERRQ2.html#SETERRQ2">SETERRQ2</A>(<A HREF="../Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>,PETSC_ERR_ARG_OUTOFRANGE,"Column too large: col %D max %D",in[j],mat-&gt;cmap-&gt;N-1);
#endif
else {
if (mat-&gt;was_assembled) {
if (!aij-&gt;colmap) {
ierr = MatCreateColmap_MPIAIJ_Private(mat);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
}
#if defined(PETSC_USE_CTABLE)
ierr = PetscTableFind(aij-&gt;colmap,in[j]+1,&amp;col);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
col--;
#else
col = aij-&gt;colmap[in[j]] - 1;
#endif
if (col &lt; 0 &amp;&amp; !((Mat_SeqAIJ*)(aij-&gt;A-&gt;data))-&gt;nonew) {
ierr = MatDisAssemble_MPIAIJ(mat);<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
col  =  in[j];
/* Reinitialize the variables required by MatSetValues_SeqAIJ_B_Private() */
B     = aij-&gt;B;
b     = (Mat_SeqAIJ*)B-&gt;data;
bimax = b-&gt;imax; bi = b-&gt;i; bilen = b-&gt;ilen; bj = b-&gt;j;
rp2   = bj + bi[row];
ap2   = ba + bi[row];
rmax2 = bimax[row];
nrow2 = bilen[row];
low2  = 0;
high2 = nrow2;
bm    = aij-&gt;B-&gt;rmap-&gt;n;
ba    = b-&gt;a;
}
} else col = in[j];
MatSetValues_SeqAIJ_B_Private(row,col,value,addv);
}
}
} else if (!aij-&gt;donotstash) {
if (roworiented) {
ierr = MatStashValuesRow_Private(&amp;mat-&gt;stash,im[i],n,in,v+i*n,(<A HREF="../Sys/PetscBool.html#PetscBool">PetscBool</A>)(ignorezeroentries &amp;&amp; (addv == <A HREF="../Sys/ADD_VALUES.html#ADD_VALUES">ADD_VALUES</A>)));<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
} else {
ierr = MatStashValuesCol_Private(&amp;mat-&gt;stash,im[i],n,in,v+i,m,(<A HREF="../Sys/PetscBool.html#PetscBool">PetscBool</A>)(ignorezeroentries &amp;&amp; (addv == <A HREF="../Sys/ADD_VALUES.html#ADD_VALUES">ADD_VALUES</A>)));<A HREF="../Sys/CHKERRQ.html#CHKERRQ">CHKERRQ</A>(ierr);
}
}
}
}
PetscFunctionReturnVoid();
}
<P>
<P><B><P><B><FONT COLOR="#CC3333">Level:</FONT></B>advanced
<BR><FONT COLOR="#CC3333">Location:</FONT></B><A HREF="../../../src/mat/impls/aij/mpi/mpiaij.c.html#MatCreateMPIAIJWithSplitArrays">src/mat/impls/aij/mpi/mpiaij.c</A>
<BR><A HREF="./index.html">Index of all Mat routines</A>
<BR><A HREF="../../index.html">Table of Contents for all manual pages</A>
<BR><A HREF="../singleindex.html">Index of all manual pages</A>
</BODY></HTML>
