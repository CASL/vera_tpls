#include <mpi.h>
#include <pmpio.h>
#include <string.h>
#include <stdlib.h>
/* Define this symbol BEFORE including hdf5.h to indicate the HDF5 code
   in this file uses version 1.6 of the HDF5 API. This is harmless for
   versions of HDF5 before 1.8 and ensures correct compilation with
   version 1.8 and thereafter. When, and if, the HDF5 code in this file
   is explicitly upgraded to the 1.8 API, this symbol should be removed. */
#define H5_USE_16_API
#include <hdf5.h>

typedef struct _user_data {
    hid_t groupId;
} user_data_t;

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the create callback
 *-----------------------------------------------------------------------------
 */
void *CreateHDF5File(const char *fname, const char *nsname, void *userData)
{
    hid_t *retval = 0;
    hid_t h5File = H5Fcreate(fname, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    if (h5File >= 0)
    {
        user_data_t *ud = (user_data_t *) userData;
        ud->groupId = H5Gcreate(h5File, nsname, 0);
        retval = (hid_t *) malloc(sizeof(hid_t));
        *retval = h5File;
    }
    return (void *) retval;
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the open callback
 *-----------------------------------------------------------------------------
 */
void *OpenHDF5File(const char *fname, const char *nsname,
                   PMPIO_iomode_t ioMode, void *userData)
{
    hid_t *retval;
    hid_t h5File = H5Fopen(fname,
                       ioMode == PMPIO_WRITE ? H5F_ACC_RDWR : H5F_ACC_RDONLY,
                       H5P_DEFAULT);
    if (h5File >= 0)
    {
        if (ioMode == PMPIO_WRITE)
        {
            user_data_t *ud = (user_data_t *) userData;
            ud->groupId = H5Gcreate(h5File, nsname, 0);
        }
        retval = (hid_t *) malloc(sizeof(hid_t));
        *retval = h5File;
    }
    return (void *) retval;
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the close callback
 *-----------------------------------------------------------------------------
 */
void CloseHDF5File(void *file, void *userData)
{
    user_data_t *ud = (user_data_t *) userData;
    H5Gclose(ud->groupId);
    H5Fclose(*((hid_t*) file));
    free(file);
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Main 
 * Purpose:     Demonstrate use of PMPIO 
 * Description:
 * This simple program demonstrates the use of PMPIO to write a set of hdf5
 * files. Each processor will write a randomly sized array of at most 1024
 * intergers to its own sub-directory in a HDF5 file. By default, this program
 * will generate 3 hdf5 files, regardless of the number of processors it is
 * run on. You can change the number of files generated by passing an integer
 * as an argument to the program. The following line will compile this example.
 *
 *     mpicc -g -I. -I/usr/gapps/hdf5/1.6.5/LinuxE3/serial/64/optim/include
 *     pmpio_hdf5_test.c -o pmpio_hdf5_test
 *     -L/usr/gapps/hdf5/1.6.5/LinuxE3/serial/64/optim/lib -lhdf5 -lz -lm
 *
 * To run it, try something like...
 *
 *     mpirun -np 17 pmpio_hdf5_test 3
 *-----------------------------------------------------------------------------
 */
int main(int argc, char **argv)
{
    int size, rank;
    int numGroups = 3;
    hid_t *h5File_ptr;
    hid_t h5File;
    hid_t h5Group;
    char fileName[256], nsName[256];
    int i, len;
    int *theData;
    user_data_t userData;

    if (argc >= 2)
        numGroups = atoi(argv[1]);

    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    PMPIO_baton_t *bat = PMPIO_Init(numGroups, PMPIO_WRITE, MPI_COMM_WORLD, 1,
        CreateHDF5File, OpenHDF5File, CloseHDF5File, &userData);

    sprintf(fileName, "pmpio_hdf5_data_%03d.h5", bat->groupRank);
    sprintf(nsName, "domain_%03d", bat->rankInComm);

    h5File_ptr = (hid_t *) PMPIO_WaitForBaton(bat, fileName, nsName);
    h5File = *h5File_ptr;
    h5Group = userData.groupId;

    /* this processor's local work on the file */
    /* note: libhdf5 futz's with srand during initialization. Putting
       the srand call here AFTER the first HDF5 calls, fixes that. */
    srand(rank*13371);
    len = rand() % 1024;
    theData = (int *) malloc(len * sizeof(int));
    for (i = 0; i < len; i++)
        theData[i] = i;

    /* new scope for local dataset vars */
    /* note: use the group id as the loc-id for the H5Dcreate call */
    {
        hsize_t hlen = (hsize_t) len;
        hid_t spaceId = H5Screate_simple(1, &hlen, 0);
        hid_t dataId = H5Dcreate(h5Group, "theData", H5T_NATIVE_INT,
                                 spaceId, H5P_DEFAULT);
        H5Dwrite(dataId, H5T_NATIVE_INT, spaceId, spaceId,
                    H5P_DEFAULT, theData);
        H5Sclose(spaceId);
        H5Dclose(dataId);
    }

    PMPIO_HandOffBaton(bat, h5File_ptr);

    PMPIO_Finish(bat);

    MPI_Finalize();

    return 0;
}
